"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AxePuppeteer: () => AxePuppeteer,
  default: () => src_default,
  loadPage: () => loadPage
});
module.exports = __toCommonJS(src_exports);

// src/axePuppeteer.ts
var import_assert2 = __toESM(require("assert"));

// src/browser.ts
function pageIsLoaded() {
  return document.readyState === "complete";
}
function axeRunPartialSupport() {
  return typeof window.axe.runPartial === "function";
}
function axeConfigure(config) {
  if (config) {
    window.axe.configure(config);
  }
  window.axe.configure({
    branding: { application: "axe-puppeteer" }
  });
}
function axeGetFrameContext(context) {
  return window.axe.utils.getFrameContexts(context);
}
function axeShadowSelect(axeSelector) {
  return window.axe.utils.shadowSelect(axeSelector);
}
function axeRunPartial(context, options) {
  return window.axe.runPartial(context, options);
}
function axeFinishRun(options) {
  return window.axe.finishRun(JSON.parse(window.partialResults), options);
}
function axeRunLegacy(context, options) {
  return window.axe.run(context || document, options || {});
}
function chunkResultString(chunk) {
  window.partialResults ??= "";
  window.partialResults += chunk;
}

// src/legacy.ts
var fs = __toESM(require("fs"));

// ../../node_modules/cross-dirname/dist/esm/index.mjs
var EXTRACT_PATH_REGEX = /@?(?<path>[file:\/\/]?[^\(\s]+):[0-9]+:[0-9]+/;
var WIN_POSIX_DRIVE_REGEX = /^\/[A-Z]:\/*/;
var getPathFromErrorStack = () => {
  let path = "";
  const stack = new Error().stack;
  if (!stack) {
    console.warn("Error has no stack!");
    return path;
  }
  let initiator = stack.split("\n").slice(4, 5)[0];
  if (!initiator) {
    initiator = stack.split("\n").slice(3, 4)[0];
  }
  if (initiator) {
    path = EXTRACT_PATH_REGEX.exec(initiator)?.groups?.path || "";
  }
  if (!initiator || !path) {
    console.warn("Can't get path from error stack!");
  }
  return path;
};
var getPath = () => {
  let path = getPathFromErrorStack();
  const protocol = "file://";
  if (path.indexOf(protocol) >= 0) {
    path = path.slice(protocol.length);
  }
  if (WIN_POSIX_DRIVE_REGEX.test(path)) {
    path = path.slice(1).replace(/\//g, "\\");
  }
  return path;
};
var getFilename = () => {
  let filename = getPath();
  return filename;
};

// src/legacy.ts
var import_url = require("url");
async function injectJS(frame, { source, selector, logOnError, args }) {
  if (!frame) {
    return;
  }
  const frames = await frame.$$(selector);
  const injections = [];
  for (const frameElement of frames) {
    const subFrame = await frameElement.contentFrame();
    const p = injectJS(subFrame, {
      source,
      selector,
      args,
      logOnError: true
    });
    injections.push(p);
  }
  const reportError = () => {
    console.error(`Failed to inject axe-core into frame (${frame.url()})`);
  };
  let injectP;
  if (!source) {
    injectP = injectJSModule(frame);
  } else {
    injectP = injectJSSource(frame, source, args);
  }
  if (logOnError) {
    injectP = injectP.catch(reportError);
  }
  injections.push(injectP);
  return Promise.all(injections).then(() => void 0);
}
async function injectJSModule(frame) {
  let axeCorePath = "";
  if (typeof require === "function" && typeof require.resolve === "function") {
    axeCorePath = require.resolve("axe-core");
  } else {
    const { createRequire } = await import("module");
    const filename = (0, import_url.pathToFileURL)(getFilename()).toString();
    const require2 = createRequire(filename);
    axeCorePath = require2.resolve("axe-core");
  }
  const source = fs.readFileSync(axeCorePath, "utf8");
  await injectJSSource(frame, source);
}
function injectJSSource(frame, source, args = []) {
  return frame.evaluate(source, ...args);
}
function iframeSelector(disabledFrameSelectors) {
  let selector = "iframe";
  for (const disabledFrameSelector of disabledFrameSelectors) {
    selector += `:not(${disabledFrameSelector})`;
  }
  return selector;
}

// src/axePartialRunner.ts
var AxePartialRunner = class {
  constructor(partialPromise, initiator = false) {
    this.initiator = initiator;
    this.partialPromise = caught(partialPromise);
  }
  partialPromise;
  childRunners = [];
  addChildResults(childResultRunner) {
    this.childRunners.push(childResultRunner);
  }
  async getPartials() {
    try {
      const parentPartial = await this.partialPromise;
      const childPromises = this.childRunners.map((childRunner) => {
        return childRunner ? caught(childRunner.getPartials()) : [null];
      });
      const childPartials = (await Promise.all(childPromises)).flat(1);
      return [parentPartial, ...childPartials];
    } catch (e) {
      if (this.initiator) {
        throw e;
      }
      return [null];
    }
  }
};
var caught = /* @__PURE__ */ ((f) => {
  return (p) => (p.catch(f), p);
})(() => {
});

// src/utils.ts
var import_assert = __toESM(require("assert"));
var fs2 = __toESM(require("fs"));
var import_url2 = require("url");
async function frameSourceInject(frame, source, config) {
  await assertFrameReady(frame);
  if (!source) {
    let axeCorePath = "";
    if (typeof require === "function" && typeof require.resolve === "function") {
      axeCorePath = require.resolve("axe-core");
    } else {
      const { createRequire } = await import("module");
      const filename = (0, import_url2.pathToFileURL)(getFilename()).toString();
      const require2 = createRequire(filename);
      axeCorePath = require2.resolve("axe-core");
    }
    source = fs2.readFileSync(axeCorePath, "utf8");
  }
  await frame.evaluate(source);
  await frame.evaluate(axeConfigure, config);
}
function arrayify(src) {
  if (!Array.isArray(src)) {
    return [src];
  }
  return src;
}
function normalizeContext(includes, excludes, disabledFrameSelectors) {
  const base = {
    exclude: []
  };
  if (excludes.length && Array.isArray(base.exclude)) {
    base.exclude.push(...excludes);
  }
  if (disabledFrameSelectors.length && Array.isArray(base.exclude)) {
    const frameExcludes = disabledFrameSelectors.map((frame) => [frame, "*"]);
    base.exclude.push(...frameExcludes);
  }
  if (includes.length) {
    base.include = includes;
  }
  return base;
}
async function getChildFrame(frame, childSelector) {
  const frameElm = await frame.evaluateHandle(axeShadowSelect, childSelector);
  return await frameElm.asElement()?.contentFrame() || null;
}
async function assertFrameReady(frame) {
  try {
    const timeoutPromise = new Promise((resolve, reject) => {
      setTimeout(() => {
        reject();
      }, 1e3);
    });
    const evaluatePromise = frame.evaluate(pageIsLoaded);
    const readyState = await Promise.race([timeoutPromise, evaluatePromise]);
    (0, import_assert.default)(readyState);
  } catch {
    throw new Error("Page/Frame is not ready");
  }
}

// src/axePuppeteer.ts
var AxePuppeteer = class {
  frame;
  axeSource;
  includes;
  excludes;
  axeOptions;
  config;
  disabledFrameSelectors;
  page;
  legacyMode = false;
  errorUrl;
  constructor(pageFrame, source) {
    if ("mainFrame" in pageFrame) {
      if ("browser" in pageFrame) {
        this.page = pageFrame;
      } else {
        console.warn(
          "AxePuppeteer support for Puppeteer <= 3.0.3 is deprecated"
        );
      }
      this.frame = pageFrame.mainFrame();
    } else {
      console.warn(
        "AxePuppeteer construction with Frame objects is deprecated."
      );
      this.frame = pageFrame;
    }
    this.axeSource = source;
    this.includes = [];
    this.excludes = [];
    this.axeOptions = {};
    this.config = null;
    this.disabledFrameSelectors = [];
    this.errorUrl = "https://github.com/dequelabs/axe-core-npm/blob/develop/packages/puppeteer/error-handling.md";
  }
  /**
   * Selector to include in analysis.
   * This may be called any number of times.
   */
  include(selector) {
    this.includes.push(selector);
    return this;
  }
  /**
   * Selector to exclude in analysis.
   * This may be called any number of times.
   */
  exclude(selector) {
    this.excludes.push(selector);
    return this;
  }
  /**
   * Set options to be passed into axe-core
   */
  options(options) {
    this.axeOptions = options;
    return this;
  }
  /**
   * Limit analysis to only the specified rules.
   * Cannot be used with `AxeBuilder#withTags`
   */
  withRules(rules) {
    rules = arrayify(rules);
    if (!this.axeOptions) {
      this.axeOptions = {};
    }
    this.axeOptions.runOnly = {
      type: "rule",
      values: rules
    };
    return this;
  }
  /**
   * Limit analysis to only specified tags.
   * Cannot be used with `AxeBuilder#withRules`
   */
  withTags(tags) {
    tags = arrayify(tags);
    if (!this.axeOptions) {
      this.axeOptions = {};
    }
    this.axeOptions.runOnly = {
      type: "tag",
      values: tags
    };
    return this;
  }
  /**
   * Set the list of rules to skip when running an analysis.
   */
  disableRules(rules) {
    rules = arrayify(rules);
    const newRules = {};
    for (const rule of rules) {
      newRules[rule] = {
        enabled: false
      };
    }
    this.axeOptions.rules = newRules;
    return this;
  }
  /**
   * Set configuration for `axe-core`.
   * This value is passed directly to `axe.configure()`
   */
  configure(config) {
    (0, import_assert2.default)(
      typeof config === "object",
      "AxePuppeteer needs an object to configure. See axe-core configure API."
    );
    this.config = config;
    return this;
  }
  /**
   * Exclude specific frames from a test
   */
  disableFrame(selector) {
    this.disabledFrameSelectors.push(selector);
    return this;
  }
  /**
   * Use frameMessenger with <same_origin_only>
   *
   * This disables use of axe.runPartial() which is called in each frame, and
   * axe.finishRun() which is called in a blank page. This uses axe.run() instead,
   * but with the restriction that cross-origin frames will not be tested.
   */
  setLegacyMode(legacyMode = true) {
    this.legacyMode = legacyMode;
    return this;
  }
  async analyze(callback) {
    try {
      const axeResults = await this.analyzePromise();
      if (callback) {
        callback(null, axeResults);
      }
      return axeResults;
    } catch (err) {
      if (callback) {
        callback(err);
        return null;
      }
      throw err;
    }
  }
  async analyzePromise() {
    const { frame, axeSource, config } = this;
    const context = normalizeContext(
      this.includes,
      this.excludes,
      this.disabledFrameSelectors
    );
    await frameSourceInject(frame, axeSource, config);
    const runPartialSupported = await frame.evaluate(axeRunPartialSupport);
    if (runPartialSupported !== true || this.page === void 0 || this.legacyMode) {
      return this.runLegacy(context);
    }
    const partialRunner = await this.runPartialRecursive(frame, context);
    const partials = await partialRunner.getPartials();
    try {
      return await this.finishRun(partials);
    } catch (error) {
      throw new Error(
        `${error.message}
 Please check out ${this.errorUrl}`
      );
    }
  }
  async runPartialRecursive(frame, context) {
    const frameContexts = await frame.evaluate(axeGetFrameContext, context);
    const options = this.axeOptions;
    const partialPromise = frame.evaluate(axeRunPartial, context, options);
    const initiator = frame === this.frame;
    const axePartialRunner = new AxePartialRunner(partialPromise, initiator);
    for (const { frameSelector, frameContext } of frameContexts) {
      try {
        let childResults = null;
        const childFrame = await getChildFrame(frame, frameSelector);
        if (childFrame) {
          await frameSourceInject(childFrame, this.axeSource, this.config);
          childResults = await this.runPartialRecursive(
            childFrame,
            frameContext
          );
        }
        axePartialRunner.addChildResults(childResults);
      } catch {
        axePartialRunner.addChildResults(null);
      }
    }
    return axePartialRunner;
  }
  async finishRun(partialResults) {
    const { axeOptions, axeSource, config, page } = this;
    (0, import_assert2.default)(page, "Running AxePuppeteer with a frame object is deprecated");
    const browser = page.browser();
    const blankPage = await browser.newPage();
    (0, import_assert2.default)(
      blankPage,
      "Please make sure that you have popup blockers disabled."
    );
    await frameSourceInject(blankPage.mainFrame(), axeSource, config);
    const sizeLimit = 6e7;
    const partialString = JSON.stringify(partialResults);
    async function chunkResults(result) {
      const chunk = result.substring(0, sizeLimit);
      await blankPage.evaluate(chunkResultString, chunk);
      if (result.length > sizeLimit) {
        return await chunkResults(result.substr(sizeLimit));
      }
    }
    await chunkResults(partialString);
    return await blankPage.evaluate(axeFinishRun, axeOptions).finally(async () => {
      await blankPage.close();
    });
  }
  async runLegacy(context) {
    const options = this.axeOptions;
    const selector = iframeSelector(this.disabledFrameSelectors);
    const source = this.axeSource;
    let config = this.config;
    if (!this.legacyMode) {
      config = {
        ...config || {},
        allowedOrigins: ["<unsafe_all_origins>"]
      };
    }
    await injectJS(this.frame, { source, selector });
    await injectJS(this.frame, {
      source: axeConfigure,
      selector,
      args: [config]
    });
    return this.frame.evaluate(axeRunLegacy, context, options);
  }
};

// src/load-page.ts
async function loadPage(browser, url, pageOpts = {}) {
  const page = await browser.newPage();
  await page.setBypassCSP(true);
  await page.goto(url, pageOpts.opts);
  return new OwningAxePuppeteer(page, pageOpts.source);
}
var OwningAxePuppeteer = class extends AxePuppeteer {
  newPage;
  constructor(page, source) {
    super(page, source);
    this.newPage = page;
  }
  async analyze(callback) {
    try {
      return await super.analyze(callback);
    } finally {
      await this.newPage.close();
    }
  }
};

// src/index.ts
var src_default = AxePuppeteer;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AxePuppeteer,
  loadPage
});

if (module.exports.default) {
  var ___default_export = module.exports.default;
  var ___export_entries = Object.entries(module.exports);
  module.exports = ___default_export;
  ___export_entries.forEach(([key, value]) => {
    if (module.exports[key]) {
      throw new Error(`Export "${key}" already exists on default export`);
    }

    module.exports[key] = value;
  });
}
